# 双RAM控制系统说明文档

## 系统概述
本系统基于STM32F4实现了双RAM（通过FPGA）的读写控制，使用74HC595驱动数码管显示，74HC138进行位选，并通过拨码开关和LED进行交互。

## 硬件配置

### 主要参数
- 主频：82MHz
- 定时器TIM4：1ms中断用于数码管扫描

### 引脚分配

#### 按钮（带消抖，高电平有效）
- PC9  -> GPIO_EXTI9：按钮0（写入数据）
- PC12 -> GPIO_EXTI12：按钮1（异或操作）

#### LED指示灯（PB0-PB7，高电平点亮）
- LED0 (PB0)：系统运行指示（常亮）
- LED1 (PB1)：写入模式指示
- LED2 (PB2)：选择RAM0指示
- LED3 (PB3)：选择RAM1指示
- LED4 (PB4)：地址bit0指示
- LED5 (PB5)：地址bit1指示
- LED6 (PB6)：保留
- LED7 (PB7)：保留

#### 拨码开关（PC0-PC7，GPIO_Input）
- SW0 (PC0)：模式选择（0=读出，1=写入）
- SW1 (PC1)：RAM选择（0=RAM0，1=RAM1）
- SW2 (PC2)：待写入数据bit0
- SW3 (PC3)：待写入数据bit1
- SW4 (PC4)：目标地址bit0
- SW5 (PC5)：目标地址bit1
- SW6 (PC6)：保留
- SW7 (PC7)：保留

#### 数码管控制（74HC595 + 74HC138）
- PA0 -> SI（74HC595串行数据输入）
- PA1 -> RCK（74HC595寄存器时钟）
- PA2 -> SCK（74HC595移位时钟）
- PA3 -> A（74HC138地址线A）
- PA4 -> B（74HC138地址线B）
- PA5 -> C（74HC138地址线C）

#### 双RAM接口（连接到FPGA，PF端口）

**RAM A端口（RAM0）：**
- PF6  -> CLKA（时钟，持续提供）
- PF0  -> WEA（写使能）
- PF7  -> ADDRA（地址）
- PF4  -> DATA_I_A[0]（数据输入bit0）
- PF5  -> DATA_I_A[1]（数据输入bit1）
- PF2  -> DATA_O_A[0]（数据输出bit0）
- PF3  -> DATA_O_A[1]（数据输出bit1）

**RAM B端口（RAM1）：**
- PF14 -> CLKB（时钟，持续提供）
- PF8  -> WEB（写使能）
- PF15 -> ADDRB（地址）
- PF12 -> DATA_I_B[0]（数据输入bit0）
- PF13 -> DATA_I_B[1]（数据输入bit1）
- PF10 -> DATA_O_B[0]（数据输出bit0）
- PF11 -> DATA_O_B[1]（数据输出bit1）

**注意**：
- RAM默认处于输出模式（无需ENA/ENB控制）
- 两块RAM的时钟需要持续提供
- 写入时序：WE拉高 → 数据稳定 → 时钟上升沿 → WE拉低

## 功能说明

### 1. 模式控制（SW0）
- **SW0=0（读出模式）**：只有LED0亮
- **SW0=1（写入模式）**：LED0和LED1都亮

### 2. RAM选择（SW1）
- **SW1=0**：选择RAM0，LED2亮
- **SW1=1**：选择RAM1，LED3亮

### 3. 数据输入（SW2, SW3）
- 通过SW2和SW3组合输入2位数据（0-3）
- 当前待写入的数据显示在最后一位数码管（第8位）

### 4. 地址控制（SW4, SW5）
- 通过SW4和SW5组合输入地址（0-3）
- 地址值通过LED4和LED5以二进制方式显示
- 两片RAM保持相同的地址

### 5. 数码管显示（8位数码管，二进制格式）
- **位1**：RAM1数据bit0（最右边）
- **位2**：RAM1数据bit1
- **位3**：RAM0数据bit0（带小数点）
- **位4**：RAM0数据bit1
- **位5-6**：保留（清零）
- **位7**：待写入数据bit0
- **位8**：待写入数据bit1（最左边）
- 显示格式示例：`10  00.11` 表示待写入数据=10，RAM0=00，RAM1=11

### 6. 按钮功能

#### 按钮0（PC9）- 数据写入
- 功能：将SW2/SW3配置的数据写入到SW1选定的RAM
- 条件：只在写入模式（SW0=1）下有效
- 目标：由SW1选择RAM，SW4/SW5确定地址
- 操作：按下按钮0 → 数据写入 → 数码管更新显示

#### 按钮1（PC12）- 异或操作
- 功能：对两个RAM的数据执行异或运算并写回
- 条件：任意模式下都可执行
- 操作流程：
  1. 从RAM0[当前地址]读取数据
  2. 从RAM1[当前地址]读取数据
  3. 计算异或：result = RAM0 XOR RAM1
  4. 将结果写回SW1选定的RAM[当前地址]
- 示例：RAM0[0]=01, RAM1[0]=11, SW1=0 → 异或结果10写入RAM0[0]

## 工作流程示例

### 写入数据到RAM0
1. 设置SW0=1（进入写入模式）→ LED0和LED1亮
2. 设置SW1=0（选择RAM0）→ LED2亮
3. 设置SW4=0, SW5=0（地址=00）
4. 设置SW2=1, SW3=0（数据=01）→ 第8位数码管显示1
5. 按下按钮0 → 数据01写入RAM0地址00

### 执行异或操作
1. 设置地址SW4/SW5（例如地址=00）
2. 设置SW1选择目标RAM（例如SW1=0写回RAM0）
3. 按下按钮1
4. 系统自动：
   - 读取RAM0[00]和RAM1[00]
   - 计算异或结果
   - 写回RAM0[00]

### 读取和显示
1. 设置SW0=0（读出模式）→ 只有LED0亮
2. 通过SW4/SW5设置要查看的地址
3. 数码管1-4位实时显示两片RAM在当前地址的数据

## 技术细节

### 数码管扫描
- 使用TIM4定时器1ms中断
- 8位数码管依次扫描显示
- 74HC595负责段选（8段）
- 74HC138负责位选（8位）

### RAM时序
**写入时序**：
1. 设置地址
2. 拉高写使能（WE）
3. 设置数据（确保数据稳定）
4. 时钟上升沿（触发写入）
5. 拉低写使能（完成写入）

**读取时序**：
1. 确保写使能为低（WE=0）
2. 设置地址
3. 时钟上升沿（触发读取）
4. 读取输出数据（RAM默认输出模式）

**注意事项**：
- RAM默认输出模式，无需EN控制
- 时钟需要持续提供
- 数据跳变和时钟上升沿错开
- 使用软件延时确保时序稳定

### 数据宽度和时钟
- RAM数据宽度：2位（0-3）
- RAM地址宽度：1位（0-1，但SW控制支持0-3）
- 拨码开关组合：2位数据、2位地址
- RAM时钟：持续提供，82MHz系统时钟

## 注意事项

1. **FPGA连接**：确保FPGA端的dual_ram模块已正确烧录
2. **RAM模式**：RAM默认为输出模式，无需ENA/ENB控制
3. **时钟要求**：两块RAM的时钟需要持续提供
4. **写入时序**：确保WE、数据和时钟的时序正确，数据跳变和时钟错开
5. **按钮消抖**：硬件已实现消抖，软件添加延时
6. **数码管刷新**：1ms扫描周期，8位轮流显示
7. **地址范围**：虽然SW支持0-3，但RAM实际只有2个地址（0-1）
8. **电平逻辑**：LED和按钮均为高电平有效

## 文件结构

```
Core/
├── Inc/
│   ├── main.h              # 主头文件，包含引脚定义和函数声明
│   ├── stm32f4xx_hal_conf.h
│   └── stm32f4xx_it.h      # 中断处理头文件
├── Src/
│   ├── main.c              # 主程序，包含所有功能实现
│   ├── stm32f4xx_it.c      # 中断服务程序
│   ├── stm32f4xx_hal_msp.c
│   └── system_stm32f4xx.c
└── README.md               # 本文档
```

## 主要函数说明

- `HC595_SendByte()`: 通过74HC595发送段码
- `HC138_Select()`: 通过74HC138选择数码管位
- `Update_Display()`: 数码管扫描更新（定时器中断调用）
- `Read_Switches()`: 读取拨码开关状态
- `Update_LEDs()`: 更新LED显示状态
- `RAM_Write()`: 写入数据到RAM
- `RAM_Read()`: 从RAM读取数据
- `Update_Display_Buffer()`: 更新数码管显示缓冲区
- `HAL_GPIO_EXTI_Callback()`: 按钮中断处理
- `HAL_TIM_PeriodElapsedCallback()`: 定时器中断处理

## 调试建议

1. 首先测试LED显示是否正确响应拨码开关
2. 测试数码管是否正常扫描显示
3. 单独测试RAM写入和读取功能
4. 最后测试异或操作功能
5. 使用逻辑分析仪检查RAM时序信号